package task4;

actor Approx () uint(size=8) ByteIn ==> uint(size=8) ByteOut:

  //Local Variable
  bool DEBUG := false;
  uint(size=32) BYTES_PER_FRAME := 152064;
  uint(size=8)  BYTES[BYTES_PER_FRAME];
  uint(size=32) nbByteRead;
  uint(size=32) nbByteSent;
  uint(size=32) nbFrame;
  
  uint(size=32) Y_SIZE  := 101376;
  uint(size=32) UV_SIZE := 25344;
  uint(size=8)  Y[Y_SIZE];
  uint(size=8)  U[UV_SIZE];
  uint(size=8)  V[UV_SIZE];
  uint(size=32) yuv_offset;
  uint(size=32) y_offset;
  uint(size=32) u_offset;
  uint(size=32) v_offset;
  uint(size=32) key=2; //2^1
  
  //action initialize
  initialize ==>
  do	
	if (DEBUG) then
	  println("# ACTION: initialize");
	  println("Next STATE: BufferFrame");
	  println("-------------------------");
	end
	nbByteRead         := 0;
	nbByteSent         := 0;
	nbFrame            := 1;
  end
  
  // Action ReadData	
  readData.start: action ByteIn:[In] ==>
  guard
    nbByteRead < BYTES_PER_FRAME
  do
    if(DEBUG) then
       println("# ACTION: readData.start");
       println("Frame: " + nbFrame + ", BYTES[" + nbByteRead + "]=" + In);
    end
    BYTES[nbByteRead] := In;
    nbByteRead := nbByteRead+1;
  end
  
  // Action ReadData.done	
  readData.done: action ==>
  guard
    nbByteRead = BYTES_PER_FRAME
  do
    if(DEBUG) then
       println("# ACTION: readData.done");
       println("Frame: " + nbFrame + ", nbByteRead=" + nbByteRead);
       println("Next STATE: SeperateYUV");		
	   println("-------------------------");
    end
    nbByteRead := 0;
    yuv_offset := 0;
  end
  
  // Action readYUV.start	
  readYUV.start: action  ==>
  guard
    yuv_offset < BYTES_PER_FRAME
  var
    uint(size=32) u_offset_local, uint(size=32) v_offset_local
  do
    if(DEBUG) then
       println("# ACTION: readYUV.start");
    end
    if(yuv_offset<Y_SIZE) then
       Y[yuv_offset] := BYTES[yuv_offset];
       if(DEBUG) then
          println("Y["+yuv_offset+"]=BYTES["+yuv_offset+"] = " + BYTES[yuv_offset]);
       end
    else
       if ( (yuv_offset>= Y_SIZE) and yuv_offset < (Y_SIZE+UV_SIZE)) then
          U[yuv_offset-Y_SIZE] := BYTES[yuv_offset];
          u_offset_local := yuv_offset-Y_SIZE;
          if(DEBUG) then
             println("U["+u_offset_local+"]=BYTES["+yuv_offset+"] = " + BYTES[yuv_offset]);
          end
       else
          V[yuv_offset-Y_SIZE-UV_SIZE] := BYTES[yuv_offset];
          v_offset_local := yuv_offset-Y_SIZE-UV_SIZE;
          if(DEBUG) then
             println("V["+v_offset_local+"]=BYTES["+yuv_offset+"] = " + BYTES[yuv_offset]);
          end
       end 
    end
    yuv_offset := yuv_offset+1;
  end
  
  // Action readYUV.done	
  readYUV.done: action  ==>
  guard
    yuv_offset = BYTES_PER_FRAME
  do
    if(DEBUG) then
       println("# ACTION: readYUV.done");
       println("Next STATE: ApproxYUV");		
	   println("-------------------------");
    end
    y_offset := 0;
    u_offset := 0;
    v_offset := 0;
  end
  
  // Action 	
  approxY: action  ==>
  guard
    y_offset < Y_SIZE
  var
    uint(size=8) sample_value, uint(size=8) approx_value, uint(size=32) multi
  do
    sample_value := Y[y_offset];
    //Start Approximation
    multi := sample_value/key;
    approx_value := multi*key;
    if(DEBUG) then
       println("# ACTION: approxY");
       println("Y[" + y_offset + "]: sample=" + sample_value + ", multi=" + multi + ", approx=" + approx_value);
    end
    // End Approximation
    Y[y_offset] := approx_value;
    y_offset := y_offset + 1;
  end
  
  // Action 	
  approxU: action  ==>
  guard
    u_offset < UV_SIZE
  var
    uint(size=8) sample_value, uint(size=8) approx_value, uint(size=32) multi
  do
    sample_value := U[u_offset];
    //Start Approximation
    multi := sample_value/key;
    approx_value := multi*key;
    if(DEBUG) then
       println("# ACTION: approxU");
       println("Y[" + y_offset + "]: sample=" + sample_value + ", multi=" + multi + ", approx=" + approx_value);
    end
    // End Approximation
    U[u_offset] := approx_value;
    u_offset := u_offset + 1;
  end
  
  // Action 	
  approxV: action  ==>
  guard
    v_offset < UV_SIZE
  var
    uint(size=8) sample_value, uint(size=8) approx_value, uint(size=32) multi
  do
    sample_value := V[v_offset];
    //Start Approximation
    multi := sample_value/key;
    approx_value := multi*key;
    if(DEBUG) then
       println("# ACTION: approxV");
       println("Y[" + y_offset + "]: sample=" + sample_value + ", multi=" + multi + ", approx=" + approx_value);
    end
    // End Approximation
    V[v_offset] := approx_value;
    v_offset := v_offset + 1;
  end
  
  // Action 	
  approxYUV.done: action  ==>
  guard
    y_offset = Y_SIZE and u_offset = UV_SIZE and v_offset = UV_SIZE
  do
    if(DEBUG) then
       println("# ACTION: approxYUV.done");
       println("Next STATE: MergeYUV");		
	   println("-------------------------");
    end
    yuv_offset := 0;
  end
  
  // Action 	
  mergeYUV.start: action  ==>
  guard
    yuv_offset < BYTES_PER_FRAME
  var
    uint(size=32) u_offset_local, uint(size=32) v_offset_local
  do
    if(DEBUG) then
       println("# ACTION: mergeYUV.start");
    end
    if(yuv_offset<Y_SIZE) then
       BYTES[yuv_offset] := Y[yuv_offset];
       if(DEBUG) then
          println("BYTES["+yuv_offset+"]=Y["+yuv_offset+"]");
       end
    else
       if ( (yuv_offset>= Y_SIZE) and yuv_offset < (Y_SIZE+UV_SIZE)) then
          BYTES[yuv_offset] := U[yuv_offset-Y_SIZE];
          u_offset_local := yuv_offset-Y_SIZE;
          if(DEBUG) then
             println("BYTES["+yuv_offset+"] = U["+u_offset_local+"]");
          end
       else
          BYTES[yuv_offset] := V[yuv_offset-Y_SIZE-UV_SIZE] ;
          v_offset_local := yuv_offset-Y_SIZE-UV_SIZE;
          if(DEBUG) then
             println("BYTES["+yuv_offset+"] = V["+v_offset_local+"]");
          end
       end 
    end
    yuv_offset := yuv_offset+1;
  end
  
    // Action 	
  mergeYUV.done: action  ==>
  guard
    yuv_offset = BYTES_PER_FRAME
  do
    if(DEBUG) then
       println("# ACTION: mergeYUV.done");
       println("Next STATE: SendFrame");		
	   println("-------------------------");
    end
    nbByteSent := 0;
  end
  
    // Action sendData
  sendData.start: action ==> ByteOut:[Out]
  guard
	nbByteSent < BYTES_PER_FRAME 
  var
	uint(size=8) Out
  do
    if(DEBUG) then
       println("# ACTION: sendData.start");
       println("Frame: " + nbFrame + ", Send BYTES[" + nbByteSent + "]=" + Out);
    end
	Out := BYTES[nbByteSent];
	nbByteSent := nbByteSent + 1;
  end
  
  // Action sendData.done
  sendData.done: action ==>
  guard
	nbByteSent = BYTES_PER_FRAME 
  do
    if(DEBUG) then
       println("# ACTION: sendData.done");
       println("nbByteSent=" + nbByteSent);
       println("nbFrame=" + nbFrame);
       println("Next STATE: BufferFrame");		
	   println("-------------------------");
    end
	nbFrame := nbFrame + 1;
	nbByteRead         := 0;
  end
  
  // FSM
  schedule fsm BufferFrame:
	BufferFrame   (readData.start) --> BufferFrame;
	BufferFrame   (readData.done)  --> SeperateYUV;
	SeperateYUV   (readYUV.start)  --> SeperateYUV;
	SeperateYUV   (readYUV.done)   --> ApproxYUV;
	ApproxYUV     (approxY)        --> ApproxYUV;
	ApproxYUV     (approxU)        --> ApproxYUV;
	ApproxYUV     (approxV)        --> ApproxYUV;
	ApproxYUV     (approxYUV.done) --> MergeYUV;
	MergeYUV      (mergeYUV.start) --> MergeYUV;
	MergeYUV      (mergeYUV.done)  --> SendFrame;
	SendFrame     (sendData.start) --> SendFrame;
	SendFrame     (sendData.done)  --> BufferFrame;
  end	

end